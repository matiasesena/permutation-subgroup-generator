# NAME: Permutation subgroup generator
# AUTHOR: Matias Ezequiel Sena
# VERSION: 1.0
# SUBJECT: Criptography I
# CAREER: Master of Science in Information Security
# UNIVERSITY: University of Buenos Aires

## FUNCTIONS

# This func asks the user to input the length and generator that will be used.
def getGenerator():
    generator = list()
    print('\033[1m'+"INPUT"+'\033[0m')
    # Get the length of the group.
    print("\tEnter the LENGTH of the Group of Permutations. - e.g. N = 5")
    try:
        length = int(raw_input('\tN = '))
    except ValueError:
            print("\n[!] You have to enter an interger for N.")
            return []
    # Check if length is greater than 0.
    if length < 1:
        print("\n[!] You have to enter an interger N >= 1.")
        return []
    # Get the generator to create the subgroup.
    print("\n\tEnter the GENERATOR you want to use to calculate the subgroup - e.g. P = (132)(45)")
    for i in range(0, length):
        try:
            new_number = int(raw_input('\t'+str(i+1)+'-> '))
            generator.append(new_number)
        except ValueError:
            print("\n[!] You have to enter an intergers as part of P.")
            return []
    # Check if the generator is valid.
    for i in range(0, length):
        if i + 1 not in generator:
            print("\n[!] You have to enter numbers that exist in the selected group {1,...,"+str(length)+"}")
            return []
    print('\n\033[1m'+"OUTPUT"+'\033[0m')
    print("\tSubgroup generated by the permutation: {}".format(changeFormatElement(generator)))
    numbers = list()
    for i in range(0, len(generator)):
        numbers.append(i + 1)
    return generator

# This func does the bijective function P.
def permute(generator, permuted_element):
    result = list()
    for i in range(0, len(generator)):
        result.append(permuted_element[generator[i]-1])
    return result

# This func checks if the element is the identity permutation.
def checkIdentity(element):
    next_number = 1
    for number in element:
        if number == next_number:
            next_number = next_number + 1
        else:
            return False
    return True

# This creates the elements that can be generated by the permutation given.
def generateSubGroup(generator):
    subGroup = list()
    isIdentity = 0
    permuted_element = generator
    count = 2
    print("\n\tP^1 = {}".format(changeFormatElement(generator)))
    subGroup.append(permuted_element)
    if checkIdentity(permuted_element):
        isIdentity = 1
    # When we find the identity element, we finish.
    while isIdentity == 0:
        permuted_element = permute(generator, permuted_element)
        print("\tP^{} = {}".format(count, changeFormatElement(permuted_element)))
        subGroup.append(permuted_element)
        if checkIdentity(permuted_element):
            isIdentity = 1
        count = count+1
    return subGroup

# This func changes the format from list to string (permutation writing).
def changeFormatElement(element):
    string = '('
    pos = 0
    next_number = element[pos]
    done = list()
    not_done = list()
    for i in range(0,len(element)):
        not_done.append(i + 1)
    done.append(pos + 1)
    not_done.remove(pos + 1)
    if next_number == pos + 1:
        string += str(element[pos]) + ')('
        pos = pos + 1
    else:
        string += str(pos + 1) + str(next_number)
        not_done.remove(next_number)
        done.append(next_number)
        pos = next_number - 1
        next_number = element[pos]
    if len(element) != 1:
        next_number = element[pos]
    else:
        string = string.rstrip('()')
    while len(not_done) > 0:
        if next_number in done:
            done.append(pos + 1)
            if pos+1 in not_done:
                not_done.remove(pos+1)
            if len(not_done) != 0:
                if not string.endswith('('):
                    string += ')('
                pos = not_done[0] - 1
                next_number = element[pos]
            else:
                string += str(pos + 1)
        else:
            if next_number == pos + 1:
                done.append(element[pos])
                not_done.remove(element[pos])
                if len(not_done) != 0:
                    string += str(element[pos]) + ')('
                    pos = pos + 1
                else:
                    string += str(element[pos])
            else:
                if pos+1 in not_done:
                    string += str(pos + 1)+str(next_number)
                    done.append(pos + 1)
                    not_done.remove(pos + 1)
                else:
                    string += str(next_number)
                done.append(next_number)
                not_done.remove(next_number)
                pos = next_number - 1
            if len(not_done) != 0:
                next_number = element[pos]
    string += ')'
    return string

# This func creates the file with the transitions calculated.
def writeOutput(subGroup):
    filename = "permutations_done.txt"
    outputFile = open(filename,"w+")
    for i in range(0,len(subGroup)):
        if i == len(subGroup) - 1:
            outputFile.write("P^{}\n".format(i+1))
        else:
            outputFile.write("P^{}\t".format(i+1))
    for i in range(0,len(subGroup[0])):
        for j in range(0,len(subGroup)):
            if j == len(subGroup) - 1:
                outputFile.write("{}\n".format(subGroup[j][i]))
            else:
                outputFile.write("{} ->\t".format(subGroup[j][i]))
    print("\t[-] The file has been created successfully: permutations_done.txt")


## MAIN PROGRAM
if __name__ == "__main__":
    # Print the header.
    print('\n\033[1m'+"NAME"+'\033[0m')
    print("\tPermutation subgroup generator - Criptography I\n")
    print('\033[1m'+"DESCRIPTION"+'\033[0m')
    print("\tThis script calculates the subgroup generated by the permutation")
    print("\t(generator) that you enter.\n")
    print("\tGiven a set A, we note by S(A) as the Group of bijections of A in A with")
    print("\tthe composition. If n >= 1 is a natural number, S(N) denotes the group")
    print("\tof bijections of the set {1,...,N}. The S(N) elements are permutations.\n")
    print('\033[1m'+"AUTHOR"+'\033[0m')
    print("\tWritten by Matias Ezequiel Sena.\n")
    print('\033[1m'+"NOTES"+'\033[0m')
    print("\tThe purpose of the script is to fulfill a practical work of the subject")
    print("\tCriptography I, part of the UBA's Information Security career.\n")
    print("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n")
    print("[-] Permutation subgroup generator has started.\n")
    # Get the generator from user's input.
    generator = getGenerator()
    if generator:
        # Generate the subgroup generated by the permutation.
        subGroup = generateSubGroup(generator)
        # Ask the user if he wants to save the output in a file.
        choice = raw_input('\n\tDo you want to save all the permutations in a file? Select Yes or No (y/n): ')
        if choice == 'y' or choice == 'Y':
            # Write the file with all the transitions.
            writeOutput(subGroup)
        print("\n[-] Permutation subgroup generator has finished.")
